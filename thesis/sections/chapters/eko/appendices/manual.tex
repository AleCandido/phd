In this section we provide an extremely brief manual about \eko{} usage.
We give here the instruction for the release version associated to this paper.
A more expanded and updated manual for the current version can be found in the on-line documentation:

\begin{center}
\url{https://eko.readthedocs.io/en/latest/overview/tutorials/index.html}
\end{center}

\subsection{Installation}

The installation provided to the user of the package is very simple.

We require only:
\begin{itemize}
    \item a working installation of Python 3\footnote{
            The exact Python version support can be found on the official
            \texttt{PyPI} (Python Package Index, the official Python registry)
            \eko{} page, see \url{https://pypi.org/project/eko/}.
        } and
    \item the official Python package manager
        \href{https://pip.pypa.io/}{\texttt{pip}}, usually bundled together any
        distribution of Python itself.
\end{itemize} 
You can check their availability on your system with:
\begin{lstlisting}[language=sh]
    python3 --version
    python3 -m pip --version
\end{lstlisting}
(for a non \texttt{sh} based environment, e.g.\ Windows, check the official
Python documentation).

The actual installation of the package can be obtained with the following
command:
\begin{lstlisting}[language=sh]
    python3 -m pip install eko==0.8.5
\end{lstlisting}

\subsection{Usage}

Using \eko{} as an evolution application is pretty simple, involving the call
of a single function to produce an evolution operator.

Nevertheless, it has been intentionally left up to the user the definition of
all the settings required for a run.
This might be confusing for a newcomer, but it is the best approach since the
actual settings might be different for any given application, and there is no
one that can be recommended as a \textit{best practice}; in order to not suggest
such an interpretation, we decided to not provide any defaults, and to require
the user to be aware of the whole set of settings.

We present now a minimal example, in which the settings are taken from the official
benchmarking setup in \cite{Giele:2002hx} (which is not worse nor better than any other choice).
To be able to access the toy PDF established in \cite{Giele:2002hx} you need to install in addition our benchmarking package:
\begin{lstlisting}[language=sh]
    python3 -m pip install banana-hep==0.6.6
\end{lstlisting}
Then you are set to run the following snippet:
\begin{lstlisting}[language=Python]
import numpy as np
import eko # of course we need eko
from banana import toy # load the official toy PDF

# theory setting
th_card = {
    "HQ": "POLE", # heavy quark mass scheme
    "IB": 0, # allow intrinsic bottom?
    "IC": 0, # allow intrinsic charm?
    "MaxNfAs": 6, # max number of flavor in alpha_s evolution
    "MaxNfPdf": 6, # max number of flavor in pdf evolution
    "ModEv": "EXA", # evolution mode
    "PTO": 0, # perturbation order of evolution: 0=LO, 1=NLO, 2=NNLO
    "Q0": np.sqrt(2.0), # fitting scale [GeV]
    "Qmb": 4.5, # MSbar reference scale for bottom mass [GeV]
    "Qmc": np.sqrt(2.0), # MSbar reference scale for charm mass [GeV]
    "Qmt": 175., # MSbar reference scale for top mass [GeV]
    "Qref": np.sqrt(2.0), # reference scale for alpha_s [GeV]
    "alphas": 0.35, # reference value for alpha_s
    "fact_to_ren_scale_ratio": 1.0, # scale variation ratio
    "kbThr": 1.0, # matching ratio to bottom mass
    "kcThr": 1.0, # matching ratio to charm mass
    "ktThr": 1.0, # matching ratio to top mass
    "mb": 4.5, # bottom mass [GeV]
    "mc": np.sqrt(2.0), # charm mass [GeV]
    "mt": 175., # top mass [GeV]
    "nf0": 3, # number of flavors at fitting scale
    "nfref": 3, # number of flavors at alpha_s reference scale
}
# operator settings
op_card = {
    "Q2grid": [10000.], # final scale grid
    "backward_inversion": "expanded", # backward inversion method
    "debug_skip_non_singlet": False, # debug option
    "debug_skip_singlet": False, # debug option
    "ev_op_iterations": 10, # number of iterations for solver
    "ev_op_max_order": 10, # expansion order of solver
    "interpolation_is_log": True, # use logarithmic interpolation?
    "interpolation_polynomial_degree": 4, # polynomial degree of interpolation
    "interpolation_xgrid": eko.interpolation.make_grid(30, 30), # interpolation grid ranging from 1e-7 to 1
}

# 1. compute the eko
evolution_operator = eko.run_dglap(th_card, op_card)
# 2. load the initial PDF (only for border condition) - any lhapdf like object will do
pdf = toy.mkPDF("", 0)
# 3. contract the given PDF with the eko
evolved_pdfs = evolution_operator.apply_pdf(pdf)
# then e.g. print the evolved gluon (pid = 21) at Q2 = 10000 GeV^2 for the first point x=1e-7
print(evolved_pdfs[10000.]["pdfs"][21][0])
# if we multiply with x again we obtain 1.3263e3
# The reference value from the official benchmark is 1.3272e3
# This is compatible with Fig. 1
print(1e-7 * evolved_pdfs[10000.]["pdfs"][21][0])
# or we can print the value of alpha_s at this scale, which also matches the reference value: 0.122306
print(evolution_operator["Q2grid"][10000.]["alphas"])
\end{lstlisting}

For more information about the settings, please refer to the online documentation.

Note, that the reference values for the gluon and the strong coupling are taken from \cite[Table 2]{Giele:2002hx}.

Also note, that the example may not work with newer version 
of the code, for which, instead, we recommend to follow the online tutorials.
